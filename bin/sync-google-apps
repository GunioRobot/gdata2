#!/usr/bin/env ruby
#
#
$: << '../lib'

require 'rubygems'
require 'sqlite3'
require 'net/ldap'
require 'optparse'
require 'digest/sha1'
require 'thread'
require 'timeout'
require 'faster_csv'

require 'gdata'
require 'gdata/apps'
require 'timestamp'

$options = OpenStruct.new
$queue = Queue.new
$sync = Mutex.new
$source = nil
$count = 0

class State
   attr_reader :timestamp

   def initialize(fn, timestamp="19700000000000Z")
      @mutex = Mutex.new
      @updates = Queue.new
      @running = true

      puts "Creating state db updated thread" if $options.verbose
      process_updates

      if !File.exists?(fn)
         needs_initialization = 1
      end

      puts "Creating new state database." if $options.verbose

      @db = SQLite3::Database.new(fn)

      if needs_initialization
         do_initialization
      else
         @timestamp = @db.execute("SELECT * FROM updates;")[0]
      end
   end

   def do_initialization
      puts "Initializing state database." if $options.verbose

      @db.execute("CREATE TABLE users (idx TEXT PRIMARY KEY, last_modified TEXT);")
      @db.execute("CREATE TABLE updates (ts TEXT);")
   end

   def reset
      puts "Resetting state database." if $options.verbose
      @db.execute("DELETE FROM users;")
      @timestamp = "19700000000000Z"
      update_timestamp
   end

   def show_users
      ts = @db.execute("SELECT * FROM updates;")[0]
      puts "Last touched: #{ts}"

      puts "Dumping users:"
      @db.execute("SELECT * FROM users;") do |user|
         puts user.join(", ")
      end
   end

   def update_timestamp
      @timestamp=Time.now.gmtime.strftime("%Y%m%d%H%M00Z")

      @db.execute("DELETE FROM updates;")
      @db.execute("INSERT INTO updates (ts) VALUES ('#{@timestamp}');")
   end

   def count_users
      @db.execute("SELECT count(*) FROM users;")
   end

   def exists?(entry)
      ts = @db.execute("SELECT last_modified FROM users WHERE 'idx=#{entry}';")
      if ts.length > 0
         return true
      else
         return false
      end
   end

   def push_update(entry)
      @updates << { entry => Time.now.gmtime.strftime("%Y%m%d%H%M00Z") }
   end

   def process_updates
      @updater = Thread.new do
         puts "Creating process update thread." if $options.debug
         while @running || ! @updates.empty?
            if @updates.length > 0
               puts "Processing state update" if $options.debug
               entry,ts = @updates.pop
               update(entry,ts)
            end
         end
         puts "Exiting process update thread." if $options.debug
         Thread.exit
      end
   end

   def update(entry, ts=nil)
      ts ||= Time.now.gmtime.strftime("%Y%m%d%H%M00Z")

      @mutex.synchronize {
         if exists?(entry)
            puts "Updating #{entry} with TS: #{ts}" if $options.debug
            @db.execute("UPDATE users SET last_modified = '#{ts}' WHERE 'idx=#{entry}';")
         else
            puts "Inserting #{entry} with TS: #{ts}" if $options.debug
            @db.execute("INSERT INTO users (idx, last_modified) VALUES ('#{entry}', '#{ts}');")
         end
      }
   end

   def check(entry, source_stamp)
      source = Time.parse(source_stamp[0])
      ts = @db.execute("SELECT last_modified FROM users WHERE 'idx=#{entry}';")[0]
      if ts.nil?
         return true
      end
      last_modified = Time.parse(ts)
      if ts < source
         puts "Check -> Entry old, returning true" if $options.verbose
         return true
      else
         puts "Check -> Entry up to date, returning false" if $options.verbose
         return false
      end
   end

   def stop
      @running = false
   end
end

def random_password(size = 12)
   chars = (('a'..'z').to_a + ('0'..'9').to_a) - %w(i o 0 1 l 0)
   password = (1..size).collect{|a| chars[rand(chars.size)] }.join
   #  sha1 = Digest::SHA1.hexdigest(password)
   return password
end

def parse_uids(uid_array, dn)
   uid_dn = dn.split(',')[0].split('=')[1]
   uid_alias = nil
   uid_array.each do |uid|
      if uid.match(uid_dn)
         uid_dn = uid
      else
         uid_alias = uid
      end
   end

   if uid_alias.nil?
      uid_alias = uid_dn
   end
   return uid_dn, uid_alias
end

def create_and_update_user(apps, entry, config)
   uid_dn, uid_alias = parse_uids(entry.uid, entry.dn)
   username = uid_dn
   first = entry.givenname
   last = entry.sn
   password = random_password
   nickname = uid_alias
   update = false

   # First create them
   backoff_factor = 2
   result = nil
   while result.nil?
      begin
         # create user
         puts "Creating user #{username}." if $options.verbose
         result = apps.provision.create_user(username, first, last, password)
      rescue Timeout::Error
         retry
      rescue GData::GDataError => e
         puts "errorcode = " +e.code+ " input : "+e.input+" reason : "+e.reason if $options.debug
         if e.code == "503"
            result = nil
            sleep(backoff_factor)
            backoff_factor *= backoff_factor
         elsif e.code = "1300"
            update = true
            break
         end
      end
   end

   # Then set the password reset to false so they don't have to change it at next login
   backoff_factor = 2
   result = nil
   while result.nil?
      begin
         # update so they don't have to change their password at next login
         puts "Setting password reset to false for #{username}." if $options.verbose
         result = apps.provision.update_user(username, first, last, nil, nil, nil, nil, "false", nil )
      rescue Timeout::Error
         retry
      rescue GData::GDataError => e
         puts "errorcode = " +e.code+ " input : "+e.input+" reason : "+e.reason if $options.verbose
         if e.code == "503"
            result = nil
            sleep(backoff_factor)
            backoff_factor *= backoff_factor
         elsif e.code = "1300"
            update = true
            break
         end
      end
   end

   if uid_dn != uid_alias
      # Finally add the email address they know about
      backoff_factor = 2
      result = nil
      while result.nil?
         begin
            # Add the email address they're used to seeing
            puts "Adding alias #{nickname} to #{username}." if $options.verbose
            result = apps.provision.create_nickname(username, nickname)
         rescue Timeout::Error
            retry
         rescue GData::GDataError => e
            puts "errorcode = " +e.code+ " input : "+e.input+" reason : "+e.reason if $options.debug
            if e.code == "503"
               result = nil
               sleep(backoff_factor)
               backoff_factor *= backoff_factor
            elsif e.code = "1300"
               update = true
               break
            end
         end
      end
   end

   if $options.forward
      address_list = config['forwards']
      entry.montanaEduPersonClassicRoles.each do |role|
         domain = address_list[role[0..2]]
         forward = "#{nickname}@#{domain}"

         # Set the forward if we are doing that
         backoff_factor = 2
         result = nil
         while result.nil?
            begin
               # Add the email address they're used to seeing
               puts "Adding mailforward #{forward} to #{username}." if $options.verbose
               result = apps.mail.update_forward(username, forward)
            rescue Timeout::Error
               retry
            rescue GData::GDataError => e
               puts "errorcode = " +e.code+ " input : "+e.input+" reason : "+e.reason if $options.debug
               if e.code == "503"
                  result = nil
                  sleep(backoff_factor)
                  backoff_factor *= backoff_factor
               elsif e.code = "1300"
                  update = true
                  break
               end
            end
         end
      end
   end

   if config['apps']['domain'] != config['apps']['maildomain']
      # This means we need a send_as alias
      backoff_factor = 2
      result = nil
      send_as_name = "#{first} #{last}"
      send_as_alias = "#{nickname}@#{config['apps']['maildomain']}"
      while result.nil?
         begin
            # Add the email address they're used to seeing
            puts "Adding send_as_alias #{send_as_name} / #{send_as_alias} to #{username}." if $options.verbose
            result = apps.mail.create_send_as(username, send_as_name, send_as_alias, send_as_alias, true)
         rescue Timeout::Error
            retry
         rescue GData::GDataError => e
            puts "errorcode = " +e.code+ " input : "+e.input+" reason : "+e.reason if $options.debug
            if e.code == "503"
               result = nil
               sleep(backoff_factor)
               backoff_factor *= backoff_factor
            elsif e.code = "1300"
               update = true
               break
            end
         end
      end
   end
   
   $sync.synchronize {
     $count += 1
   }
   if ($count % 100)
     puts "#{Time.now.strftime("%a, %d %b %Y, %l:%M%P").squeeze(' ')} : Processed #{$count}"
   end
   return update
end

def print_user(entry, config)
   puts "DN: #{entry.dn}"
   #
   # Each entry has the following attributes (from the config file)
   #
   # UniqueID: uniqueIdentifier
   # GoogleUsername: montanaEduPersonID
   # GoogleFirstName: givenName
   # GoogleLastName: sn
   # Nickname: uid
   # Affiliation: montanaEduPersonClassicRoles
   #
   uid_dn, uid_alias = parse_uids(entry.uid, entry.dn)

   print "  Message to Create account:\n"
   print "    Username: #{uid_dn}\n"
   print "    First Name: #{entry.givenname}\n"
   print "    Last Name: #{entry.sn}\n"
   print "    Uid: #{entry.uid.join(", ")}\n"
   print "    UUID: #{entry.uniqueIdentifier}\n"
   print "    Portal Email: #{uid_alias}@myportal.montana.edu\n"

   if entry.attribute_names.include?("montanaedupersonclassicroles")
      print "    Campus Email Addresses:\n"
      entry['montanaedupersonclassicroles'].each do |role|
         if role.match(/^bz/)
            print "      Bozeman Email: #{uid_alias}@msu.montana.edu\n"
         elsif role.match(/^bl/)
            print "      Billings Email: #{uid_alias}@students.msubillings.edu\n"
         elsif role.match(/^gf/)
            print "      Great Falls Email: #{uid_alias}@students.msugf.edu\n"
         elsif role.match(/^hv/)
            print "      Havre/Northern Email: #{uid_alias}@students.msun.edu\n"
         end
      end
   end

   if config["apps"].has_key?("maildomain")
      md = config["apps"]["maildomain"]
      print "    Campus Email Address: #{uid_alias}@#{md}\n"
   end
end

#
# Main Program
#

# Parse commandline options
OptionParser.new do |opts|
   $options.verbose = false
   $options.config = 'config.yml'
   $options.reset = false
   $options.debug = false
   $options.doit = true
   $options.threads = 1
   $options.output_file = nil
   $options.forward = false
   $options.operator = ">="

   opts.banner = "Usage: sync-apps.rb [options]"

   opts.on("-r", "--reset", "Reset state for synchronization.") do |o|
      $options.reset = true
      $options.operator = "<="
   end

   opts.on("-c", "--config [FILE]", "Specify a config file.") do |o|
      $options.config = o.to_s
   end

   opts.on("-v", "--verbose", "Operate verbosely.") do |o|
      $options.verbose = true
   end

   opts.on("-d", "--debug", "Operate with debug output.") do |o|
      $options.debug = true
   end

   opts.on("-n", "--not-really", "Don't really perform the operations, just pretend.") do |o|
      $options.doit = false
   end

   opts.on("-t", "--threads [# THREADS]", "The number of threads to run in parallel.") do |o|
      $options.threads = o.to_i
   end

   opts.on("-o", "--output [FILE]", "File to write output to in csv format.") do |o|
      $options.output_file = o.to_s
   end

   opts.on("-f", "--forwards", "Set forwarding addresses according to associations in configuration file.") do |o|
      $options.forward = true
   end

   opts.on_tail("--version", "Show version") do
      puts OptionParser::Version.join('.')
   end
end.parse!

# Load configuration file
config = YAML.load_file($options.config)

# Create a source object to pull data from
if config["source"]["type"] == "ldap"
   args = {
      :host => config["source"]["host"],
      :port => config["source"]["port"],
      :auth => {
         :method => :simple,
         :username => config["source"]["user"],
         :password => config["source"]["password"]
      }
   }

   if config["source"]["port"].to_i == 636
      args[:encryption] = :simple_tls
   end

   $source = Net::LDAP.new args
end

# Create a local state store for keeping track of things between runs
state_db = State.new(config["state"]["file"])
state_db.reset if $options.reset

# Get the right timestamp to compare against for retrieving users from source data
if $options.reset
   ts = Time.now.gmtime.strftime("%Y%m%d%H%M00Z")
else
   ts = state_db.timestamp
end

# Pull attributes from the directory for users that have been modified since last run
# Pull data from source
attributes = config["attributes"].values
filter_string = "(&#{config['source']['filter']}(modifytimestamp#{$options.operator}#{ts}))"
puts "Filter String: #{filter_string}" if $options.debug
filter = Net::LDAP::Filter.construct(filter_string)
accounts = $source.search(:base => config["source"]["base"], :filter => filter, :attributes => attributes)

puts "There are #{accounts.length} users in the source directory."
puts "There are #{state_db.count_users} users in the state database."

$output = nil
if not $options.output_file.nil?
   $output = FasterCSV.open($options.output_file, 'w')
   $output << ["username", "first name", "last name", "password"]
end

accounts.each do |entry|
   puts "DN: #{entry.dn}, TS: #{entry.modifyTimestamp}" if $options.debug
   if state_db.check(entry.uniqueIdentifier, entry.modifyTimestamp)
      if $output.nil?
         $queue.push(entry)
      else
         $output << ["#{entry.montanaEduPersonID}", "#{entry.givenname}", "#{entry.sn}", "#{random_password}"]
      end
   end
end

# If the goal is a csv file, don't bother calling google api
if not $output.nil?
   exit
end

# Create the Google Apps user and objects
user = config["apps"]["user"]+"@"+config["apps"]["domain"]
puts "Creating Apps Account Endpoint for #{user}." if $options.verbose
apps = GData::GApps.new(user, config["apps"]["password"])

# Create an array to store worker threads.
workers = []

# Exit if an exception occurs in a thread.
Thread.abort_on_exception = true

# Push on a terminal value for each thread
$options.threads.times do |n|
   $queue.push(:terminate)
end

$options.threads.times do |n|
   workers << Thread.new do
      loop do
         entry = $queue.pop
         break if entry == :terminate

         if create_and_update_user(apps, entry, config)
            state_db.push_update(entry.uniqueIdentifier)
         end
      end

   end
end

# Wait for workers to finish
workers.each { |w| w.join }

# Stop the state_db from updating itself
state_db.stop

# Update our local timestamp
state_db.update_timestamp if not $options.reset
